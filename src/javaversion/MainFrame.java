/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package javaversion;

import arima.ARIMA;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.SwingUtilities;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import weka.classifiers.Classifier;
import weka.classifiers.bayes.BayesNet;
import weka.classifiers.evaluation.NumericPrediction;
import weka.classifiers.functions.GaussianProcesses;
import weka.classifiers.functions.LinearRegression;
import weka.classifiers.functions.Logistic;
import weka.classifiers.functions.MultilayerPerceptron;
import weka.classifiers.functions.SGD;
import weka.classifiers.functions.SMO;
import weka.classifiers.functions.SMOreg;
import weka.classifiers.lazy.IBk;
import weka.classifiers.lazy.KStar;
import weka.classifiers.lazy.LWL;
import weka.classifiers.meta.AdaBoostM1;
import weka.classifiers.meta.AdditiveRegression;
import weka.classifiers.meta.Bagging;
import weka.classifiers.meta.LogitBoost;
import weka.classifiers.meta.RandomCommittee;
import weka.classifiers.meta.RegressionByDiscretization;
import weka.classifiers.meta.Stacking;
import weka.classifiers.meta.Vote;
import weka.classifiers.rules.DecisionTable;
import weka.classifiers.rules.JRip;
import weka.classifiers.rules.M5Rules;
import weka.classifiers.rules.OneR;
import weka.classifiers.rules.PART;
import weka.classifiers.rules.ZeroR;
import weka.classifiers.timeseries.WekaForecaster;
import weka.classifiers.trees.DecisionStump;
import weka.classifiers.trees.M5P;
import weka.classifiers.trees.REPTree;
import weka.classifiers.trees.RandomForest;
import weka.classifiers.trees.RandomTree;
import weka.core.Instances;
import weka.core.converters.CSVLoader;
import weka.estimators.UnivariateKernelEstimator;
import weka.filters.supervised.attribute.TSLagMaker;

/**
 *
 * @author user
 */
public class MainFrame extends javax.swing.JFrame {

    Instances RealDemands;

    MyClassifier algorithms[];
    Result results[];
    Result sortedResults[];

    ArrayList<Double[]> estimationOfAlgorithmsDemands = new ArrayList();

    XYSeries estimatedDataset;
    XYSeries realDataset;
    JFreeChart chart;

    /**
     * Creates new form MainFrame
     */
    public MainFrame() {
        initComponents();

//        testARMA();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList<>();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jSpinner1 = new javax.swing.JSpinner();
        jLabel2 = new javax.swing.JLabel();
        jSpinner2 = new javax.swing.JSpinner();
        jCheckBox1 = new javax.swing.JCheckBox();
        jLabel3 = new javax.swing.JLabel();
        jProgressBar1 = new javax.swing.JProgressBar();
        jLabel4 = new javax.swing.JLabel();
        jSpinner3 = new javax.swing.JSpinner();
        jLabel5 = new javax.swing.JLabel();
        jSpinner4 = new javax.swing.JSpinner();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        jButton3 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("Open file");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("run");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jList1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                jList1ValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(jList1);

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel1.setLayout(new java.awt.GridLayout(1, 0));

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane2.setViewportView(jTextArea1);

        jLabel1.setText("Known until month:");

        jSpinner1.setModel(new javax.swing.SpinnerNumberModel(120, 0, null, 1));

        jLabel2.setText("Num CPU(threads):");

        jSpinner2.setModel(new javax.swing.SpinnerNumberModel(1, 1, null, 1));

        jCheckBox1.setSelected(true);
        jCheckBox1.setText("Singular algorithm");

        jLabel3.setText("Idle");

        jLabel4.setText("Initial inventory:");

        jSpinner3.setModel(new javax.swing.SpinnerNumberModel(73, 0, null, 1));

        jLabel5.setText("Warmup months:");

        jSpinner4.setModel(new javax.swing.SpinnerNumberModel(120, 14, null, 1));

        jTextPane1.setText("the results for each item in the list below is saved on a saparate file");
        jTextPane1.setEnabled(false);
        jScrollPane3.setViewportView(jTextPane1);

        jButton3.setText("Run Baging Multilayer Perceptron");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jButton1)
                        .addComponent(jCheckBox1)
                        .addComponent(jLabel3)
                        .addComponent(jButton2)
                        .addComponent(jProgressBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jLabel2)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jSpinner2))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addComponent(jLabel5)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jSpinner4))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jLabel1)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jSpinner1))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jLabel4)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jSpinner3, javax.swing.GroupLayout.PREFERRED_SIZE, 131, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jButton3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 727, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(jSpinner3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(jSpinner4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel2)
                            .addComponent(jSpinner2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBox1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 251, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        JFileChooser jfc = new JFileChooser();
        jfc.setCurrentDirectory(new java.io.File("."));
        FileNameExtensionFilter filter = new FileNameExtensionFilter("CSV file", "csv");
        jfc.addChoosableFileFilter(filter);

        int returnValue = jfc.showOpenDialog(null);

        if (returnValue == JFileChooser.APPROVE_OPTION) {
            StringBuilder dataInString = new StringBuilder();
            BufferedReader reader;
            try {
                reader = new BufferedReader(new FileReader(jfc.getSelectedFile()));
                String line = reader.readLine();
                dataInString.append("Year,Month,Demand");
                dataInString.append(System.lineSeparator());
                line = reader.readLine();//Skip first line
                String refYear = "";
                while (line != null) {
//                    System.out.println(line);
                    String row[] = line.split(",");
                    String year = row[0];

                    if (year.length() > 0) {
                        refYear = year;
                    } else {
                        year = refYear;
                    }
                    String month = row[1];
                    String demand = row[2];
                    dataInString.append(year);
                    dataInString.append(",");
                    dataInString.append(month);
                    dataInString.append(",");
                    dataInString.append(demand);
                    dataInString.append(System.lineSeparator());
                    line = reader.readLine();
                }
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
//            System.out.println(dataInString.toString());

            CSVLoader csvLoader = new CSVLoader();
            try {
                InputStream stream = new ByteArrayInputStream(dataInString.toString().getBytes(StandardCharsets.UTF_8));
                csvLoader.setSource(stream);
                RealDemands = csvLoader.getDataSet();

                estimatedDataset = new XYSeries("Estimated values");
                realDataset = new XYSeries("Real values");
                for (int i = 0; i < RealDemands.numInstances(); i++) {
                    realDataset.add(i + 1, RealDemands.get(i).value(2));
                }
                XYSeriesCollection xYDataset = new XYSeriesCollection();
                xYDataset.addSeries(estimatedDataset);
                xYDataset.addSeries(realDataset);
                chart = ChartFactory.createXYLineChart("Demand", "Month", "Value", xYDataset);
                ChartPanel panel = new ChartPanel(chart);
                panel.setBounds(0, 0, jPanel1.getWidth(), jPanel1.getHeight());
                jPanel1.add(panel);

            } catch (IOException ex) {
                Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        jLabel3.setText("Running");
        if (jCheckBox1.isSelected() == true) {
            runAllAlgorithmsSeparately();
        } else {
            runAllAlgorithmsSimultanously();
        }

//        
////\/\/\/ LAST MONTH
//                month = 120;
////\/\/\/ BEGINGIN OF MONTH
//        if InventoryLevel(month) <= RealDemands(month, 3) + BackOrder(month) + 73
//    
//            BackOrder(month + 1) = (RealDemands(month, 3) + BackOrder(month)) - InventoryLevel(month);
//        InventoryLevel(month) = 0;
//        OrderAmount(month) = BackOrder(month + 1) + 73 - InventoryLevel(month);
//        elseif InventoryLevel(month)>RealDemands(month, 3) + BackOrder(month) + 73
//        InventoryLevel(month) = InventoryLevel(month) - (RealDemands(month, 3) + BackOrder(month) + 73);
//        BackOrder(month + 1) = 0;
//        OrderAmount(month) = BackOrder(month + 1) + 73 - InventoryLevel(month);
//        end //^^^ BEGINGIN OF MONTH
//                //\/\/\/ END OF MONTH
//
//        if InventoryLevel(month) < 90
//    
//            TotalCost = TotalCost + InventoryLevel(month) * 1;
//        else {
//            TotalCost = TotalCost + InventoryLevel(month) * 2;
//        }
//        end TotalCost = TotalCost + BackOrder(month) * 3;
//        InventoryLevel(month + 1) = OrderAmount(month);
//^^^ END OF MONTH
//^^^ LAST MONTH
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jList1ValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList1ValueChanged
        // TODO add your handling code here:
        if (jList1.getSelectedIndex() > -1) {
            int selectedAlgorithm = Integer.valueOf(jList1.getSelectedValue().split(" ")[0]);
            String string = "Algorithm name: " + results[selectedAlgorithm].algorithmName + System.lineSeparator();
            string = string + "Total cost: " + results[selectedAlgorithm].totalCost + System.lineSeparator();
            jTextArea1.setText(string);
            refreshGUI();
        }
    }//GEN-LAST:event_jList1ValueChanged

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:
        jLabel3.setText("Running");
        setupBestAlgorithms();
        results = new Result[1];
        results[0] = new Result();
        results[0].algorithmName = algorithms[0].name + "Not done ";

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < results.length; i++) {
                    results[i] = testOneAlgoritmSeparately(algorithms[i]);
                    SwingUtilities.invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            refreshGUI();
                        }
                    });
                }
                try {
                    saveResults(results, true);
                } catch (IOException ex) {
                    Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
                jLabel3.setText("Done");
            }
        });
        thread.start();
    }//GEN-LAST:event_jButton3ActionPerformed

    public void runAllAlgorithmsSimultanously() {
        setupForcastingAlgorithms();
        results = new Result[1];
        results[0] = new Result();
        results[0].algorithmName = "0 ActiveAlgorithm " + "Not done ";

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < results.length; i++) {
                    results[i] = testSimultanousAlgorithm(algorithms);
                    SwingUtilities.invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            refreshGUI();
                        }
                    });
                }
                try {
                    saveResults(results,false);
                } catch (IOException ex) {
                    Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
                jLabel3.setText("Done");
            }
        });
        thread.start();

    }

    public void saveResults(Result results[], boolean isBestAlgorithm) throws IOException {

        for (int al = 0; al < results.length; al++) {
            FileWriter csvWriter;
            if (isBestAlgorithm == false) {
                csvWriter = new FileWriter(results[al].algorithmName + " Results.csv", false);
            } else {
                csvWriter = new FileWriter("Best algorithm " + results[al].algorithmName + " Results.csv", false);
            }
            csvWriter.append("Begining Inventory");
            csvWriter.append("\n");
            for (int i = 0; i < results[al].BeginingInventoryLevel.length; i++) {
                csvWriter.append(String.valueOf(results[0].BeginingInventoryLevel[i]));
                csvWriter.append("\n");
            }
            csvWriter.append("Order Quantity");
            csvWriter.append("\n");
            for (int i = 0; i < results[al].OrderAmount.length; i++) {
                csvWriter.append(String.valueOf(results[al].OrderAmount[i]));
                csvWriter.append("\n");
            }

            csvWriter.append("Ending Inventory");
            csvWriter.append("\n");
            for (int i = 0; i < results[al].OrderAmount.length; i++) {
                csvWriter.append(String.valueOf(results[al].EndingInventoryLevel[i]));
                csvWriter.append("\n");
            }

            csvWriter.append("Holding Cost");
            csvWriter.append("\n");
            for (int i = 0; i < results[al].InventoryCost.length; i++) {
                csvWriter.append(String.valueOf(results[al].InventoryCost[i]));
                csvWriter.append("\n");
            }

            csvWriter.append("Backorder Cost");
            csvWriter.append("\n");
            for (int i = 0; i < results[al].BackOrderCost.length; i++) {
                csvWriter.append(String.valueOf(results[al].BackOrderCost[i]));
                csvWriter.append("\n");
            }

            csvWriter.append("Total Cost");
            csvWriter.append("\n");
            csvWriter.append(String.valueOf(results[al].totalCost));
            csvWriter.append("\n");

            csvWriter.append("Total Holding Cost");
            csvWriter.append("\n");
            csvWriter.append(String.valueOf(results[al].TotalInventoryCost));
            csvWriter.append("\n");

            csvWriter.append("Average Holding Cost");
            csvWriter.append("\n");
            csvWriter.append(String.valueOf(results[al].averageInventoryCost));
            csvWriter.append("\n");

            csvWriter.append("Total backorder Cost");
            csvWriter.append("\n");
            csvWriter.append(String.valueOf(results[al].TotalBackOrderCost));
            csvWriter.append("\n");

            csvWriter.append("Average backorder Cost");
            csvWriter.append("\n");
            csvWriter.append(String.valueOf(results[al].averageBackOrderCost));
            csvWriter.append("\n");

            csvWriter.append("Estimated demand");
            csvWriter.append("\n");
            for (int i = 0; i < results[al].EstimatedDemands.length; i++) {
                csvWriter.append(String.valueOf(results[al].EstimatedDemands[i]));
                csvWriter.append("\n");
            }

            csvWriter.flush();
            csvWriter.close();
        }
    }

    public void runAllAlgorithmsSeparately() {
        setupForcastingAlgorithms();
        jProgressBar1.setMinimum(0);
        jProgressBar1.setMaximum(algorithms.length - 1);
        results = new Result[algorithms.length];
        for (int i = 0; i < algorithms.length; i++) {
            results[i] = new Result();
            results[i].algorithmName = algorithms[i].name + "Not done ";
        }

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                Thread parallelRuns[] = new Thread[(int) jSpinner2.getValue()];
                CPUUpperLowerBounds bounds[] = CPUUpperLowerBounds.spreadTasks(parallelRuns.length, results.length);
                for (int c = 0; c < bounds.length; c++) {
                    final int passed_c = c;
                    parallelRuns[c] = new Thread(new Runnable() {
                        @Override
                        public void run() {
                            for (int i = bounds[passed_c].startIndex; i < bounds[passed_c].endIndex; i++) {
                                results[i] = testOneAlgoritmSeparately(algorithms[i]);
                                SwingUtilities.invokeLater(new Runnable() {
                                    @Override
                                    public void run() {
                                        int progress = 0;
                                        for (int i = 0; i < results.length; i++) {
                                            if (!results[i].algorithmName.contains("Not done")) {
                                                progress = progress + 1;
                                            }
                                        }
                                        jProgressBar1.setValue(progress);
                                        refreshGUI();
                                    }
                                });
                            }
                        }
                    });
                    parallelRuns[c].start();
                }
                for (int c = 0; c < bounds.length; c++) {
                    try {
                        parallelRuns[c].join();
                    } catch (InterruptedException ex) {
                        Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
                        jLabel3.setText("Error");
                    }
                }
                try {
                    saveResults(results,false);
                } catch (IOException ex) {
                    Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
                jLabel3.setText("Done");
            }
        });
        thread.start();
    }

    public void refreshGUI() {
        estimatedDataset.clear();
        if (jList1.getSelectedIndex() > -1) {
            int selectedAlgorithm = Integer.valueOf(jList1.getSelectedValue().split(" ")[0]);
            if (results[selectedAlgorithm].EstimatedDemands != null) {
                for (int i = 0; i < results[selectedAlgorithm].EstimatedDemands.length; i++) {
                    estimatedDataset.add(i + 1, results[selectedAlgorithm].EstimatedDemands[i]);
                    chart.fireChartChanged();
                }
            }
        }

        sortedResults = deepClone(results);
        Arrays.sort(sortedResults);
        jList1.setModel(new javax.swing.AbstractListModel() {
            @Override
            public int getSize() {
                return sortedResults.length;
            }

            @Override
            public Object getElementAt(int index) {
                return sortedResults[index].algorithmName;
            }
        });
    }

    public Result testSimultanousAlgorithm(MyClassifier classifiers[]) {
        int knownMonthsIndex = (int) jSpinner1.getValue();
        int warmupMonthsIndex = (int) jSpinner4.getValue();
        int initialInventory = (int) jSpinner3.getValue();
        double EstimatedDemands[] = new double[RealDemands.numInstances() + 1];
        double InventoryLevel[] = new double[RealDemands.numInstances() + 1];
        double EndingInventoryLevel[] = new double[RealDemands.numInstances() + 1];
        double BeginingInventoryLevel[] = new double[RealDemands.numInstances() + 1];
        double InventoryCost[] = new double[RealDemands.numInstances()];
        double OrderAmount[] = new double[RealDemands.numInstances()];
        double BackOrder[] = new double[RealDemands.numInstances() + 1];
        double BackOrderCost[] = new double[RealDemands.numInstances()];
        for (int month = 0; month < RealDemands.numInstances(); month++) {
            EstimatedDemands[month] = 0;
            InventoryLevel[month] = 0;
            InventoryCost[month] = 0;
            OrderAmount[month] = 0;
            BackOrder[month] = 0;
        }
        InventoryLevel[knownMonthsIndex] = initialInventory;
        double TotalCost = 0;

        jProgressBar1.setMinimum(knownMonthsIndex);
        jProgressBar1.setMaximum(RealDemands.numInstances() - 1);

        for (int i = 0; i < knownMonthsIndex; i++) {
            Double emptyEstimations[] = new Double[classifiers.length];
            for (int j = 0; j < emptyEstimations.length; j++) {
                emptyEstimations[j] = new Double(0);
            }
            estimationOfAlgorithmsDemands.add(emptyEstimations);
        }

        for (int month = knownMonthsIndex; month < RealDemands.numInstances(); month++) {
            final int passed_month = month;
            SwingUtilities.invokeLater(new Runnable() {
                @Override
                public void run() {
                    jProgressBar1.setValue(passed_month);
                }
            });

            //\/\/\/ BEGINGIN OF MONTH
            //\/\/\/ ESTIMATE DEMAND
            if (month + 1 <= knownMonthsIndex) {
                EstimatedDemands[month + 1] = RealDemands.instance(month).value(2);
            } else {
                EstimatedDemands[month + 1] = estimateNextMonthDemandSimultanously(month, classifiers, knownMonthsIndex, warmupMonthsIndex);
            }
            //^^^ ESTIMATE DEMAND
            BeginingInventoryLevel[month] = InventoryLevel[month];
            if (InventoryLevel[month] <= RealDemands.get(month).value(2) + BackOrder[month]) {
                BackOrder[month + 1] = (RealDemands.get(month).value(2) + BackOrder[month]) - InventoryLevel[month];
                InventoryLevel[month] = 0;
                OrderAmount[month] = EstimatedDemands[month + 1] + BackOrder[month + 1] - InventoryLevel[month];
            } else if (InventoryLevel[month] > RealDemands.get(month).value(2) + BackOrder[month]) {
                InventoryLevel[month] = InventoryLevel[month] - (RealDemands.get(month).value(2) + BackOrder[month]);
                BackOrder[month + 1] = 0;
                OrderAmount[month] = EstimatedDemands[month + 1] + BackOrder[month + 1] - InventoryLevel[month];
            }

            //^^^ BEGINGIN OF MONTH
            //\/\/\/ END OF MONTH
            if (InventoryLevel[month] < 90) {
                InventoryCost[month] = InventoryLevel[month] * 1;
                TotalCost = TotalCost + InventoryCost[month];
            } else {
                InventoryCost[month] = InventoryLevel[month] * 2;
                TotalCost = TotalCost + InventoryCost[month];
            }
            BackOrderCost[month] = BackOrder[month] * 3;
            TotalCost = TotalCost + BackOrderCost[month];

            EndingInventoryLevel[month] = InventoryLevel[month];

            InventoryLevel[month + 1] = InventoryLevel[month] + OrderAmount[month];
            //^^^ END OF MONTH
        }
        Result result = new Result();
        result.EstimatedDemands = EstimatedDemands;
        result.BackOrder = BackOrder;
        result.InventoryCost = InventoryCost;
        result.totalCost = TotalCost;
        result.InventoryLevel = InventoryLevel;
        result.OrderAmount = OrderAmount;
        result.TotalBackOrderCost = getSum(BackOrderCost);
        result.TotalInventoryCost = getSum(InventoryCost);
        result.averageBackOrderCost = getMean(BackOrderCost);
        result.averageInventoryCost = getMean(InventoryCost);
        result.BeginingInventoryLevel = BeginingInventoryLevel;
        result.BackOrderCost = BackOrderCost;
        result.EndingInventoryLevel = EndingInventoryLevel;
        result.algorithmName = "0 ActiveAlgorithm";

        if (Double.isNaN(result.totalCost) == true) {
            result.algorithmName = "0 ActiveAlgorithm" + "_FAILED";
            result.totalCost = 1000000000;
        }

        return result;
    }

    public Result testOneAlgoritmSeparately(MyClassifier classifier) {
        int knownMonthsIndex = (int) jSpinner1.getValue();
        int warmupMonthsIndex = (int) jSpinner4.getValue();
        int initialInventory = (int) jSpinner3.getValue();
        double EstimatedDemands[] = new double[RealDemands.numInstances() + 1];
        double InventoryLevel[] = new double[RealDemands.numInstances() + 1];
        double EndingInventoryLevel[] = new double[RealDemands.numInstances() + 1];
        double BeginingInventoryLevel[] = new double[RealDemands.numInstances() + 1];
        double InventoryCost[] = new double[RealDemands.numInstances()];
        double OrderAmount[] = new double[RealDemands.numInstances()];
        double BackOrder[] = new double[RealDemands.numInstances() + 1];
        double BackOrderCost[] = new double[RealDemands.numInstances()];
        for (int month = 0; month < RealDemands.numInstances(); month++) {
            EstimatedDemands[month] = 0;
            InventoryLevel[month] = 0;
            InventoryCost[month] = 0;
            OrderAmount[month] = 0;
            BackOrder[month] = 0;
        }
        InventoryLevel[knownMonthsIndex] = initialInventory;
        double TotalCost = 0;

        for (int month = knownMonthsIndex; month < RealDemands.numInstances(); month++) {
            //\/\/\/ BEGINGIN OF MONTH
            //\/\/\/ ESTIMATE DEMAND
            if (month + 1 <= knownMonthsIndex) {
                EstimatedDemands[month + 1] = RealDemands.instance(month).value(2);
            } else {
                EstimatedDemands[month + 1] = classifier.estimateNextMonthDemandSeparately(RealDemands, month, knownMonthsIndex, warmupMonthsIndex);
            }

            if (EstimatedDemands[month + 1] == -1) {
                Result result = new Result();
                result.algorithmName = classifier.name + "_FAILED";
//                return result;
            }
            //^^^ ESTIMATE DEMAND
            BeginingInventoryLevel[month] = InventoryLevel[month];
            if (InventoryLevel[month] <= RealDemands.get(month).value(2) + BackOrder[month]) {
                BackOrder[month + 1] = (RealDemands.get(month).value(2) + BackOrder[month]) - InventoryLevel[month];
                InventoryLevel[month] = 0;
                OrderAmount[month] = EstimatedDemands[month + 1] + BackOrder[month + 1] - InventoryLevel[month];
            } else if (InventoryLevel[month] > RealDemands.get(month).value(2) + BackOrder[month]) {
                InventoryLevel[month] = InventoryLevel[month] - (RealDemands.get(month).value(2) + BackOrder[month]);
                BackOrder[month + 1] = 0;
                OrderAmount[month] = EstimatedDemands[month + 1] + BackOrder[month + 1] - InventoryLevel[month];
            }

            //^^^ BEGINGIN OF MONTH
            //\/\/\/ END OF MONTH
            if (InventoryLevel[month] < 90) {
                InventoryCost[month] = InventoryLevel[month] * 1;
                TotalCost = TotalCost + InventoryCost[month];
            } else {
                InventoryCost[month] = InventoryLevel[month] * 2;
                TotalCost = TotalCost + InventoryCost[month];
            }
            BackOrderCost[month] = BackOrder[month] * 3;
            TotalCost = TotalCost + BackOrderCost[month];

            EndingInventoryLevel[month] = InventoryLevel[month];

            InventoryLevel[month + 1] = InventoryLevel[month] + OrderAmount[month];
            //^^^ END OF MONTH
        }
        Result result = new Result();
        result.EstimatedDemands = EstimatedDemands;
        result.BackOrder = BackOrder;
        result.InventoryCost = InventoryCost;
        result.totalCost = TotalCost;
        result.InventoryLevel = InventoryLevel;
        result.OrderAmount = OrderAmount;
        result.TotalBackOrderCost = getSum(BackOrderCost);
        result.TotalInventoryCost = getSum(InventoryCost);
        result.averageBackOrderCost = getMean(BackOrderCost);
        result.averageInventoryCost = getMean(InventoryCost);
        result.BeginingInventoryLevel = BeginingInventoryLevel;
        result.BackOrderCost = BackOrderCost;
        result.EndingInventoryLevel = EndingInventoryLevel;
        result.algorithmName = classifier.name;

        if (Double.isNaN(result.totalCost) == true) {
            result.algorithmName = classifier.name + "_FAILED";
            result.totalCost = 1000000000;
        }

        return result;
    }

    public Result[] deepClone(Result inputResults[]) {
        Result outputResults[] = new Result[inputResults.length];
        for (int i = 0; i < inputResults.length; i++) {
            outputResults[i] = new Result(inputResults[i].algorithmName, inputResults[i].totalCost, inputResults[i].averageInventoryCost, inputResults[i].averageBackOrderCost, inputResults[i].EstimatedDemands, inputResults[i].InventoryLevel, inputResults[i].InventoryCost, inputResults[i].OrderAmount, inputResults[i].BackOrder);
        }
        return outputResults;
    }

    public void setupBestAlgorithms() {
        algorithms = new MyClassifier[1];
        algorithms[0] = new MyClassifier();
        algorithms[0].type = "DM";
        algorithms[0].classifier = new Bagging();
        ((Bagging) algorithms[0].classifier).setClassifier(new MultilayerPerceptron());
        algorithms[0].name = "0 Bagging+MultilayerPerceptron";
    }

    public void setupForcastingAlgorithms() {
        algorithms = new MyClassifier[30];
        for (int i = 0; i < algorithms.length - 1; i++) {
            algorithms[i] = new MyClassifier();
            algorithms[i].type = "DM";
        }
        algorithms[29] = new MyClassifier();
        algorithms[29].name = "29 ARMA";
        algorithms[29].type = "ARMA";

        algorithms[0].classifier = new GaussianProcesses();
        algorithms[0].name = "0 GaussianProcesses";

        algorithms[1].classifier = new LinearRegression();
        algorithms[1].name = "1 LinearRegression";

//        algorithms[2].classifier = new MultilayerPerceptron();
//        algorithms[2].name = "2 MultilayerPerceptron";
        algorithms[2].classifier = new SMOreg();
        algorithms[2].name = "2 SMOreg";

        algorithms[3].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[3].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[3].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[3].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[3].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[3].classifier).setClassifier(new IBk());
//        algorithms[4].classifier = new IBk();
        algorithms[3].name = "3 IBk D";

//        algorithms[5].classifier = new RegressionByDiscretization();
//        ((RegressionByDiscretization) algorithms[5].classifier).setEstimator(new UnivariateKernelEstimator());
//        ((RegressionByDiscretization) algorithms[5].classifier).setNumBins(500);
//        ((RegressionByDiscretization) algorithms[5].classifier).setMinimizeAbsoluteError(true);
//        ((RegressionByDiscretization) algorithms[5].classifier).setUseEqualFrequency(true);
//        ((RegressionByDiscretization) algorithms[5].classifier).setClassifier(new KStar());
////        algorithms[5].classifier = new KStar();
//        algorithms[5].name = "5 KStar D";
        algorithms[4].classifier = new LWL();
        algorithms[4].name = "4 LWL";

        algorithms[5].classifier = new AdditiveRegression();
        algorithms[5].name = "5 AdditiveRegression";

        algorithms[6].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[6].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[6].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[6].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[6].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[6].classifier).setClassifier(new Bagging());
        ((Bagging) ((RegressionByDiscretization) algorithms[6].classifier).getClassifier()).setClassifier(new BayesNet());
//        algorithms[8].classifier = new Bagging();
//        ((Bagging) algorithms[8].classifier).setClassifier(new BayesNet());
        algorithms[6].name = "6 Bagging+BayesNet D";

        algorithms[7].classifier = new Bagging();
        ((Bagging) algorithms[7].classifier).setClassifier(new GaussianProcesses());
        algorithms[7].name = "7 Bagging+GaussianProcesses";

        algorithms[8].classifier = new Bagging();
        ((Bagging) algorithms[8].classifier).setClassifier(new LinearRegression());
        algorithms[8].name = "8 Bagging+LinearRegression";

//        algorithms[11].classifier = new RegressionByDiscretization();
//        ((RegressionByDiscretization) algorithms[11].classifier).setEstimator(new UnivariateKernelEstimator());
//        ((RegressionByDiscretization) algorithms[11].classifier).setNumBins(500);
//        ((RegressionByDiscretization) algorithms[11].classifier).setMinimizeAbsoluteError(true);
//        ((RegressionByDiscretization) algorithms[11].classifier).setUseEqualFrequency(true);
//        ((RegressionByDiscretization) algorithms[11].classifier).setClassifier(new Bagging());
//        ((Bagging) ((RegressionByDiscretization) algorithms[11].classifier).getClassifier()).setClassifier(new Logistic());
////        algorithms[11].classifier = new Bagging();
////        ((Bagging) algorithms[11].classifier).setClassifier(new Logistic());
//        algorithms[11].name = "11 Bagging+Logistic D";
        algorithms[9].classifier = new Bagging();
        ((Bagging) algorithms[9].classifier).setClassifier(new MultilayerPerceptron());
        algorithms[9].name = "9 Bagging+MultilayerPerceptron";

//        algorithms[13].classifier = new RegressionByDiscretization();
//        ((RegressionByDiscretization) algorithms[13].classifier).setEstimator(new UnivariateKernelEstimator());
//        ((RegressionByDiscretization) algorithms[13].classifier).setNumBins(500);
//        ((RegressionByDiscretization) algorithms[13].classifier).setMinimizeAbsoluteError(true);
//        ((RegressionByDiscretization) algorithms[13].classifier).setUseEqualFrequency(true);
//        ((RegressionByDiscretization) algorithms[13].classifier).setClassifier(new Bagging());
//        ((Bagging) ((RegressionByDiscretization) algorithms[13].classifier).getClassifier()).setClassifier(new SGD());
////        algorithms[13].classifier = new Bagging();
////        ((Bagging) algorithms[13].classifier).setClassifier(new SGD());
//        algorithms[13].name = "13 Bagging+SGD D";
        algorithms[10].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[10].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[10].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[10].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[10].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[10].classifier).setClassifier(new Bagging());
        ((Bagging) ((RegressionByDiscretization) algorithms[10].classifier).getClassifier()).setClassifier(new SMO());
//        algorithms[14].classifier = new Bagging();
//        ((Bagging) algorithms[14].classifier).setClassifier(new SMO());
        algorithms[10].name = "10 Bagging+SMO D";

        algorithms[11].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[11].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[11].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[11].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[11].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[11].classifier).setClassifier(new Bagging());
        ((Bagging) ((RegressionByDiscretization) algorithms[11].classifier).getClassifier()).setClassifier(new AdaBoostM1());
//        algorithms[15].classifier = new Bagging();
//        ((Bagging) algorithms[15].classifier).setClassifier(new AdaBoostM1());
        algorithms[11].name = "11 Bagging+AdaBoostM1(Decision stump) D";

        algorithms[12].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[12].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[12].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[12].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[12].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[12].classifier).setClassifier(new Bagging());
        ((Bagging) ((RegressionByDiscretization) algorithms[12].classifier).getClassifier()).setClassifier(new LogitBoost());
//        algorithms[16].classifier = new Bagging();
//        ((Bagging) algorithms[16].classifier).setClassifier(new LogitBoost());
        algorithms[12].name = "12 Bagging+LogitBoost (Decision stump) D";

        algorithms[13].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[13].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[13].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[13].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[13].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[13].classifier).setClassifier(new Bagging());
        ((Bagging) ((RegressionByDiscretization) algorithms[13].classifier).getClassifier()).setClassifier(new JRip());
//        algorithms[17].classifier = new Bagging();
//        ((Bagging) algorithms[17].classifier).setClassifier(new JRip());
        algorithms[13].name = "13 Bagging+JRip D";

        algorithms[14].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[14].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[14].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[14].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[14].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[14].classifier).setClassifier(new Bagging());
        ((Bagging) ((RegressionByDiscretization) algorithms[14].classifier).getClassifier()).setClassifier(new OneR());
//        algorithms[18].classifier = new Bagging();
//        ((Bagging) algorithms[18].classifier).setClassifier(new OneR());
        algorithms[14].name = "14 Bagging+OneR D";

        algorithms[15].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[15].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[15].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[15].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[15].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[15].classifier).setClassifier(new Bagging());
        ((Bagging) ((RegressionByDiscretization) algorithms[15].classifier).getClassifier()).setClassifier(new PART());
//        algorithms[19].classifier = new Bagging();
//        ((Bagging) algorithms[19].classifier).setClassifier(new PART());
        algorithms[15].name = "15 Bagging+PART D";

        algorithms[16].classifier = new RandomCommittee();
        ((RandomCommittee) algorithms[16].classifier).setClassifier(new RandomTree());
        algorithms[16].name = "16 RandomCommittee+RandomTree";

        algorithms[17].classifier = new RandomCommittee();
        ((RandomCommittee) algorithms[17].classifier).setClassifier(new GaussianProcesses());
        algorithms[17].name = "17 RandomCommittee+GaussianProcesses";

//        algorithms[22].classifier = new RandomCommittee();
//        ((RandomCommittee) algorithms[22].classifier).setClassifier(new LinearRegression());
//        algorithms[22].name = "22 RandomCommittee+LinearRegression";
//        algorithms[23].classifier = new RegressionByDiscretization();
//        ((RegressionByDiscretization) algorithms[23].classifier).setEstimator(new UnivariateKernelEstimator());
//        ((RegressionByDiscretization) algorithms[23].classifier).setNumBins(500);
//        ((RegressionByDiscretization) algorithms[23].classifier).setMinimizeAbsoluteError(true);
//        ((RegressionByDiscretization) algorithms[23].classifier).setUseEqualFrequency(true);
//        ((RegressionByDiscretization) algorithms[23].classifier).setClassifier(new RandomCommittee());
//        ((RandomCommittee) ((RegressionByDiscretization) algorithms[23].classifier).getClassifier()).setClassifier(new Logistic());
////        algorithms[23].classifier = new RandomCommittee();
////        ((RandomCommittee) algorithms[23].classifier).setClassifier(new Logistic());
//        algorithms[23].name = "23 RandomCommittee+Logistic D";
//        algorithms[24].classifier = new RandomCommittee();
//        ((RandomCommittee) algorithms[24].classifier).setClassifier(new MultilayerPerceptron());
//        algorithms[24].name = "24 RandomCommittee+MultilayerPerceptron";
//        algorithms[25].classifier = new Stacking();
//        Classifier internalClassifiers[] = new Classifier[3];
//        internalClassifiers[0] = new GaussianProcesses();
//        internalClassifiers[1] = new LinearRegression();
//        RegressionByDiscretization dcl = new RegressionByDiscretization();
//        dcl.setEstimator(new UnivariateKernelEstimator());
//        dcl.setNumBins(500);
//        dcl.setMinimizeAbsoluteError(true);
//        dcl.setUseEqualFrequency(true);
//        dcl.setClassifier(new Logistic());
//        internalClassifiers[2] = dcl;
//        ((Stacking) algorithms[25].classifier).setClassifiers(internalClassifiers);
//        algorithms[25].name = "25 Stacking+GaussianProcesses+LinearRegression+(Logistic D)";
        algorithms[18].classifier = new Stacking();
        Classifier internalClassifiers[] = new Classifier[2];
        internalClassifiers[0] = new RandomForest();
        internalClassifiers[1] = new GaussianProcesses();
        ((Stacking) algorithms[18].classifier).setClassifiers(internalClassifiers);
        algorithms[18].name = "18 Stacking+RandomForest+GaussianProcesses";

        algorithms[19].classifier = new Vote();
        internalClassifiers = new Classifier[3];
        internalClassifiers[0] = new GaussianProcesses();
        internalClassifiers[1] = new LinearRegression();
        RegressionByDiscretization dcl = new RegressionByDiscretization();
        dcl.setEstimator(new UnivariateKernelEstimator());
        dcl.setNumBins(500);
        dcl.setMinimizeAbsoluteError(true);
        dcl.setUseEqualFrequency(true);
        dcl.setClassifier(new Logistic());
        internalClassifiers[2] = dcl;
        ((Vote) algorithms[19].classifier).setClassifiers(internalClassifiers);
        algorithms[19].name = "19 Vote+GaussianProcesses+LinearRegression+(Logistic D)";

        algorithms[20].classifier = new Vote();
        internalClassifiers = new Classifier[2];
        internalClassifiers[0] = new RandomForest();
        internalClassifiers[1] = new GaussianProcesses();
        ((Vote) algorithms[20].classifier).setClassifiers(internalClassifiers);
        algorithms[20].name = "20 Vote+RandomForest+GaussianProcesses";

//        algorithms[29].classifier = new DecisionTable();
//        algorithms[29].name = "29 DecisionTable";
        algorithms[21].classifier = new M5Rules();
        algorithms[21].name = "21 M5Rules";

        algorithms[22].classifier = new ZeroR();
        algorithms[22].name = "22 ZeroR";

        algorithms[23].classifier = new DecisionStump();
        algorithms[23].name = "23 DecisionStump";

        algorithms[24].classifier = new M5P();
        algorithms[24].name = "24 M5P";

        algorithms[25].classifier = new RandomForest();
        algorithms[25].name = "25 RandomForest";

        algorithms[26].classifier = new RandomTree();
        algorithms[26].name = "26 RandomTree";

        algorithms[27].classifier = new REPTree();
        algorithms[27].name = "27 REPTree";

        algorithms[28].classifier = new RegressionByDiscretization();
        ((RegressionByDiscretization) algorithms[28].classifier).setEstimator(new UnivariateKernelEstimator());
        ((RegressionByDiscretization) algorithms[28].classifier).setNumBins(500);
        ((RegressionByDiscretization) algorithms[28].classifier).setMinimizeAbsoluteError(true);
        ((RegressionByDiscretization) algorithms[28].classifier).setUseEqualFrequency(true);
        ((RegressionByDiscretization) algorithms[28].classifier).setClassifier(new AdaBoostM1());
        ((AdaBoostM1) ((RegressionByDiscretization) algorithms[28].classifier).getClassifier()).setClassifier(new JRip());
//        algorithms[17].classifier = new Bagging();
//        ((Bagging) algorithms[17].classifier).setClassifier(new JRip());
        algorithms[28].name = "28 AdaBoostM1 D+Decision stump";

//        algorithms[38].classifier = new RegressionByDiscretization();
//        ((RegressionByDiscretization) algorithms[38].classifier).setEstimator(new UnivariateKernelEstimator());
//        ((RegressionByDiscretization) algorithms[38].classifier).setNumBins(500);
//        ((RegressionByDiscretization) algorithms[38].classifier).setMinimizeAbsoluteError(true);
//        ((RegressionByDiscretization) algorithms[38].classifier).setUseEqualFrequency(true);
//        ((RegressionByDiscretization) algorithms[38].classifier).setClassifier(new AdaBoostM1());
//        ((AdaBoostM1) ((RegressionByDiscretization) algorithms[38].classifier).getClassifier()).setClassifier(new MultilayerPerceptron());
////        algorithms[17].classifier = new Bagging();
////        ((Bagging) algorithms[17].classifier).setClassifier(new JRip());
//        algorithms[38].name = "38 AdaBoostM1 D+MultilayerPerceptron";
    }

    public double estimateNextMonthDemandSimultanously(int currentMonthIndex, MyClassifier classifiers[], int knownMonthsIndex, int warmupMonthsIndex) {
        Double generatedDemands[] = MyClassifier.makeOneMonthEstimationForAllAlgorithms(RealDemands, algorithms, currentMonthIndex, (int) jSpinner2.getValue(), knownMonthsIndex, warmupMonthsIndex);
        estimationOfAlgorithmsDemands.add(generatedDemands);
        BestAlgorithm bestAlgorithm = getBestSimultanousAlgorithmUntilNow(estimationOfAlgorithmsDemands, currentMonthIndex);
        System.out.println("Time: " + currentMonthIndex);
        System.out.println("Current classifier: " + classifiers[bestAlgorithm.index].name);
        System.out.println("Cost: " + bestAlgorithm.cost);
        return classifiers[bestAlgorithm.index].estimateNextMonthDemandSeparately(RealDemands, currentMonthIndex, knownMonthsIndex, warmupMonthsIndex);
    }

    public BestAlgorithm getBestSimultanousAlgorithmUntilNow(ArrayList<Double[]> estimations, int currentMonthIndex) {
        int knownMonthsIndex = (int) jSpinner1.getValue();
        int warmupMonthsIndex = (int) jSpinner4.getValue();
        double costs[] = new double[algorithms.length];
        for (int i = 0; i < algorithms.length; i++) {
            double estimatesForOneAlgorithm[] = new double[estimationOfAlgorithmsDemands.size()];
            for (int j = 0; j < estimationOfAlgorithmsDemands.size(); j++) {
                if (estimations.get(j)[i] != null) {
                    if (!Double.isNaN(estimations.get(j)[i])) {
                        estimatesForOneAlgorithm[j] = estimations.get(j)[i];
                    } else {
                        estimatesForOneAlgorithm[j] = Double.POSITIVE_INFINITY;
                    }
                } else {
                    estimatesForOneAlgorithm[j] = Double.POSITIVE_INFINITY;
                }
            }
            double mean = getMean(estimatesForOneAlgorithm);
            for (int j = 0; j < estimatesForOneAlgorithm.length; j++) {
                if (estimatesForOneAlgorithm[j] == -1) {
                    estimatesForOneAlgorithm[j] = mean;
                }
            }
            costs[i] = getCostUntilCurrentTime(estimatesForOneAlgorithm, currentMonthIndex, knownMonthsIndex);
        }
        int bestIndex = getMinIndex(costs);
        for (int i = 0; i < costs.length; i++) {
            System.out.println("Cost[" + i + "]: " + costs[i]);
        }
        System.out.println("Best cost index: " + bestIndex);
        return new BestAlgorithm(bestIndex, costs[bestIndex]);
    }

    public class BestAlgorithm {

        public int index;
        public double cost;

        BestAlgorithm(int passed_Index, double passed_cost) {
            index = passed_Index;
            cost = passed_cost;
        }
    }

    public double getCostUntilCurrentTime(double estimations[], int currentMonthIndex, int knownMonthsIndex) {
        int initialInventory = (int) jSpinner3.getValue();
        double InventoryLevel[] = new double[RealDemands.numInstances() + 1];
        double InventoryCost[] = new double[RealDemands.numInstances()];
        double OrderAmount[] = new double[RealDemands.numInstances()];
        double BackOrder[] = new double[RealDemands.numInstances() + 1];
        double BackOrderCost[] = new double[RealDemands.numInstances()];

        for (int month = 0; month < RealDemands.numInstances(); month++) {
            InventoryLevel[month] = 0;
            InventoryCost[month] = 0;
            OrderAmount[month] = 0;
            BackOrder[month] = 0;
        }
        InventoryLevel[knownMonthsIndex] = initialInventory;
        double TotalCost = 0;

        for (int month = knownMonthsIndex; month < currentMonthIndex; month++) {
            //\/\/\/ BEGINGIN OF MONTH
            if (InventoryLevel[month] <= RealDemands.get(month).value(2) + BackOrder[month]) {
                BackOrder[month + 1] = (RealDemands.get(month).value(2) + BackOrder[month]) - InventoryLevel[month];
                InventoryLevel[month] = 0;
                OrderAmount[month] = estimations[month + 1] + BackOrder[month + 1] - InventoryLevel[month];
            } else if (InventoryLevel[month] > RealDemands.get(month).value(2) + BackOrder[month]) {
                InventoryLevel[month] = InventoryLevel[month] - (RealDemands.get(month).value(2) + BackOrder[month]);
                BackOrder[month + 1] = 0;
                OrderAmount[month] = estimations[month + 1] + BackOrder[month + 1] - InventoryLevel[month];
            }

            //^^^ BEGINGIN OF MONTH
            //\/\/\/ END OF MONTH
            if (InventoryLevel[month] < 90) {
                InventoryCost[month] = InventoryLevel[month] * 1;
                TotalCost = TotalCost + InventoryCost[month];
            } else {
                InventoryCost[month] = InventoryLevel[month] * 2;
                TotalCost = TotalCost + InventoryCost[month];
            }
            BackOrderCost[month] = BackOrder[month] * 3;
            TotalCost = TotalCost + BackOrderCost[month];
            InventoryLevel[month + 1] = InventoryLevel[month] + OrderAmount[month];
            //^^^ END OF MONTH
        }
        return TotalCost;
    }

    public double getSum(double input[]) {
        double output = 0;
        for (int i = 0; i < input.length; i++) {
            if (input[i] >= 0) {
                output = output + input[i];
            }
        }
        return output;
    }

    public double getMean(double input[]) {
        double output = 0;
        double counter = 0;
        for (int i = 0; i < input.length; i++) {
            if (input[i] >= 0) {
                output = output + input[i];
                counter = counter + 1;
            }
        }
        return output / counter;
    }

    public int getMinIndex(double input[]) {
        for (int i = 0; i < input.length; i++) {
            if (Double.isNaN(input[i]) == true) {
                input[i] = Double.POSITIVE_INFINITY;
            }
        }
        double minValue = Double.POSITIVE_INFINITY;
        int minIndex = 0;
        for (int i = 0; i < input.length; i++) {
            if (input[i] < minValue) {
                minValue = input[i];
                minIndex = i;
            }
        }
        return minIndex;
    }

    public void testARMA() {
//        TimeSeries timeSeries = TestData.debitcards;
//        ArimaOrder modelOrder = ArimaOrder.order(0, 1, 1, 0, 1, 1);
//        Arima model = Arima.model(timeSeries, modelOrder);
//        
//        System.out.println(model.aic()); // Get and display the model AIC
//        System.out.println(model.coefficients()); // Get and display the estimated coefficients
//        System.out.println(java.util.Arrays.toString(model.stdErrors()));
//        plot(model.predictionErrors());
//        
//        Forecast forecast = model.forecast(12);
//        
//        System.out.println(forecast);

        Scanner ino = null;

        try {
            ArrayList<Double> arraylist = new ArrayList<Double>();
            ino = new Scanner(new File(System.getProperty("user.dir") + "/TestArimaData.csv"));
            while (ino.hasNext()) {
                arraylist.add(Double.parseDouble(ino.next()));
            }
            double[] dataArray = new double[arraylist.size() - 1];
            for (int i = 0; i < arraylist.size() - 1; i++) {
                dataArray[i] = arraylist.get(i);
            }

            //System.out.println(arraylist.size());
            ARIMA arima = new ARIMA(dataArray);

            int[] model = arima.getARIMAmodel();

            System.out.println("Best model is [p,q]=" + "[" + model[0] + " " + model[1] + "]");
            System.out.println("Predict value=" + arima.aftDeal(arima.predictValue(model[0], model[1])));
            System.out.println("Predict error=" + (arima.aftDeal(arima.predictValue(model[0], model[1])) - arraylist.get(arraylist.size() - 1)) / arraylist.get(arraylist.size() - 1) * 100 + "%");

            //	String[] str = (String[])list1.toArray(new String[0]);	
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            ino.close();
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JList<String> jList1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSpinner jSpinner1;
    private javax.swing.JSpinner jSpinner2;
    private javax.swing.JSpinner jSpinner3;
    private javax.swing.JSpinner jSpinner4;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextPane jTextPane1;
    // End of variables declaration//GEN-END:variables
}
